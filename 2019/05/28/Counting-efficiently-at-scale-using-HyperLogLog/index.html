<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<!--<html lang="en">-->
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>Counting efficiently at scale using HyperLogLog - Computer Stuff and Other Stuff</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=HyperLogLog>
  
    <meta name="description" content="An exploration into algorithms.">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="Computer Stuff and Other Stuff" type="application/atom+xml">
  

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    menuSettings: {
      zoom: "None"
    },
    showMathMenu: false,
    jax: ["input/TeX","output/CommonHTML"],
    extensions: ["tex2jax.js"],
    TeX: {
      extensions: ["AMSmath.js","AMSsymbols.js"],
      equationNumbers: {
        autoNumber: "AMS"
      }
    },
    tex2jax: {
      inlineMath: [["\\(", "\\)"]],
      displayMath: [["\\[", "\\]"]]
    }
  });
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"></head>

  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">Computer Stuff and Other Stuff</a>
    <div class="subtitle">By Sooham Rafiz</div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
    </ul>
  </nav>
</header>
<article class="post">
  <div class="post-title">
    <h1 class="article-title">Counting efficiently at scale using HyperLogLog</h1>
  </div>
   <div class="post-meta">
    <span class="post-time">2019-05-28</span>
  </div>
  <div class="post-content">
    <p>Counting <strong>exactly</strong> number of distinct elements from a stream at scale is intrinsically a linear problem. From a perspective of time taken, intuition tells us that we cannot skip any elements in the stream and be confident in the accuracy of our result. With regards to space required to solve the problem, a record of previously seen elements in the stream must be kept. For a stream of <code>$n$</code> distinct elements, the <strong>COUNT-DISTINCT</strong> algorithm requires <code>$\Theta(n)$</code> space.</p>
<p>For services counting distincts in huge streams, such as the number of IP addresses visiting <a href="https://google.com/" target="_blank" rel="noopener">Google</a>, the number of unique views of a popular Reddit post, the memory-to-utility ratio would not justify using <strong>COUNT-DISTINCT</strong>, instead developers can use an approximation algorithm of <strong>COUNT-DISTINCT</strong> to produce a estimate close enough at a fraction of the space needed. <strong>HyperLogLog</strong> is one such approximation algorithm.</p>
<h3 id="Implementation-of-COUNT-DISTINCT"><a href="#Implementation-of-COUNT-DISTINCT" class="headerlink" title="Implementation of COUNT-DISTINCT"></a>Implementation of COUNT-DISTINCT</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">stream_type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">COUNT_DISTINCT</span> &#123;</span><br><span class="line">    std::map&lt;stream_type, <span class="type">int</span>&gt; seen;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">COUNT_DISTINCT</span>();</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(stream_type v)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">stream_type</span>&gt;</span><br><span class="line">COUNT_DISTINCT&lt;stream_type&gt;::<span class="built_in">COUNT_DISTINCT</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">stream_type</span>&gt;</span><br><span class="line"><span class="type">void</span> COUNT_DISTINCT&lt;stream_type&gt;::<span class="built_in">add</span>(stream_type v) &#123;</span><br><span class="line">    seen[v] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">stream_type</span>&gt;</span><br><span class="line"><span class="type">void</span> COUNT_DISTINCT&lt;stream_type&gt;::<span class="built_in">count</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> seen.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="What-is-HyperLogLog-Exactly"><a href="#What-is-HyperLogLog-Exactly" class="headerlink" title="What is HyperLogLog Exactly?"></a>What is HyperLogLog Exactly?</h2><p>HyperLogLog is many things, from the perspective of computer science, it is a:</p>
<ul>
<li><strong>Streaming algorithm</strong> - an algorithm operating on read-once-only stream of data.</li>
<li><strong>Approximation algorithm</strong> - an algorithm which can be mathematically proven to produce a result within a bound of the optimal result.</li>
<li><strong>A probabilistic algorithm</strong> - an algorithm not guaranteed to be correct for every input, in fact you’ll see that HyperLogLog can be passed a stream by an adversary to make it fail by a large margin. However, if the input stream is randomly distributed has a sufficiently large <code>$n$</code>, as in most applications at scale, HyperLogLog will behave well.</li>
<li><strong>A data structure</strong>: While HyperLogLog was described as a cardinality estimation algorithm by Flajolet et. al. We can segment the logic of this algorithm into methods to create a data structure consuming elements in a stream and providing an estimation.</li>
</ul>
<p>The main principle behind HyperLogLog is understanding the effect of random hashing a stream of values. Given a hash function <code>$hash(x): D \rightarrow \&#123;0,1\&#125;^L$</code> mapping the stream domain to a string of <code>$L$</code> bits uniformly, with every bit being a independent and identically distributed random variable. Hashing to random will create a new probability distribution which is indicative of the distinct count.</p>
<p>If we <code>$hash$</code> a stream of random integers between <code>$[0, 10^9]$</code>, it is expected that 50% of hashed elements in the stream start with bit pattern <code>$1$</code>, 25% of the hashed elements start with <code>$01$</code>, 12.5% start with <code>$001$</code>, 6.25% start with <code>$0001$</code>. Intuitively it makes sense that seeing the bit pattern <code>$0^\rho1$</code> means <code>$n$</code> is at least <code>$2^&#123;\rho&#125;$</code>.</p>
<p>A simple version of HyperLogLog keeps track of the random variable <code>$r = \max(&#123;msb(hash(x_i)) : \forall i \in S&#125;)$</code> over the stream <code>$S$</code>, where <code>$msb$</code> is the index of the first non-zero most significant bit, i.e <code>$msb(0001_2) = 3$</code>, <code>$msb(1000_2) = 0$</code>, <code>$msb(0100_2) = 1$</code> and <code>$msb(0000_2) = 4$</code> over 4-bit inputs. The value of <code>$2^&#123;r&#125;$</code> is returned, with <code>$r = -\infty$</code> when the stream is empty.</p>
<h2 id="A-simple-but-naive-version-of-HyperLogLog"><a href="#A-simple-but-naive-version-of-HyperLogLog" class="headerlink" title="A simple, but naive version of HyperLogLog"></a>A simple, but naive version of HyperLogLog</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">msb_index</span><span class="params">(<span class="type">size_t</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// return the index of the left most significant bit of input i</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">sizeof</span>(<span class="type">size_t</span>) * <span class="number">8</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> nth_msb_bitmask = ((<span class="type">size_t</span>) <span class="number">1</span>) &lt;&lt; (<span class="built_in">sizeof</span>(<span class="type">size_t</span>) * <span class="number">8</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>((i &amp; nth_msb_bitmask) == <span class="number">0</span> &amp;&amp; n &lt; <span class="built_in">sizeof</span>(<span class="type">size_t</span>) * <span class="number">8</span>) &#123;</span><br><span class="line">        n++;</span><br><span class="line">        nth_msb_bitmask = ((<span class="type">size_t</span>) <span class="number">1</span>) &lt;&lt; (<span class="built_in">sizeof</span>(<span class="type">size_t</span>) * <span class="number">8</span> - <span class="number">1</span> - n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">stream_type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HyperLogLog</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> r;</span><br><span class="line">    std::hash&lt;stream_type&gt; hash_func;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HyperLogLog</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(stream_type v)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">estimate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">stream_type</span>&gt;</span><br><span class="line">HyperLogLog&lt;stream_type&gt;::<span class="built_in">HyperLogLog</span>(), <span class="built_in">hash_func</span>()  &#123;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">stream_type</span>&gt;</span><br><span class="line"><span class="type">void</span> HyperLogLog&lt;stream_type&gt;::<span class="built_in">add</span>(stream_type v) &#123;</span><br><span class="line">    <span class="type">size_t</span> hv = <span class="built_in">hash_func</span>(v);</span><br><span class="line">    r = std::<span class="built_in">max</span>(r, <span class="built_in">msb_index</span>(hv));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">stream_type</span>&gt;</span><br><span class="line"><span class="type">double</span> HyperLogLog&lt;stream_type&gt;::<span class="built_in">estimate</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The above algorithm is almost identical to a precursor of the HyperLogLog algorithm, the <a href="https://en.wikipedia.org/wiki/Flajolet%E2%80%93Martin_algorithm" target="_blank" rel="noopener">Flajolet–Martin algorithm</a>. The above algorithm has a flaw in that it has large variance, if for example the stream contains an element <code>$x$</code> for which <code>$hash(x) = 0$</code>, then regardless of the number of distinct elements, the result would be <code>$2^L$</code>. </p>
<p>To reduce the flaw, we can partition a stream <code>$S$</code> into <code>$M$</code> substreams, where <code>$M &lt; S$</code>, compute <code>$r_i$</code>  for each substream <code>$i \in \&#123;1, \ldots, M\&#125;$</code> and average the estimates given by each stream. A simple method to partition the stream is by sorting hashes of elements by their first <code>$b$</code> bits. </p>
<p>Implementing this gets closer to HyperLogLog.</p>
<h2 id="Implementation-of-HyperLogLog"><a href="#Implementation-of-HyperLogLog" class="headerlink" title="Implementation of HyperLogLog"></a>Implementation of HyperLogLog</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">msb_index</span><span class="params">(<span class="type">size_t</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// return the index of the left most significant bit of input i</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">sizeof</span>(<span class="type">size_t</span>) * <span class="number">8</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> nth_msb_bitmask = ((<span class="type">size_t</span>) <span class="number">1</span>) &lt;&lt; (<span class="built_in">sizeof</span>(<span class="type">size_t</span>) * <span class="number">8</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>((i &amp; nth_msb_bitmask) == <span class="number">0</span> &amp;&amp; n &lt; <span class="built_in">sizeof</span>(<span class="type">size_t</span>) * <span class="number">8</span>) &#123;</span><br><span class="line">        n++;</span><br><span class="line">        nth_msb_bitmask = ((<span class="type">size_t</span>) <span class="number">1</span>) &lt;&lt; (<span class="built_in">sizeof</span>(<span class="type">size_t</span>) * <span class="number">8</span> - <span class="number">1</span> - n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">stream_type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HyperLogLog</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b; <span class="comment">// partition into 2^b substreams</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m; <span class="comment">// m substreams</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>* registers;</span><br><span class="line">    std::hash&lt;stream_type&gt; hash_func;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HyperLogLog</span>(<span class="type">int</span> b);</span><br><span class="line">    ~<span class="built_in">HyperLogLog</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(stream_type v)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">estimate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">stream_type</span>&gt;</span><br><span class="line">HyperLogLog&lt;stream_type&gt;::<span class="built_in">HyperLogLog</span>(<span class="type">unsigned</span> <span class="type">int</span> b): <span class="built_in">b</span>(b), <span class="built_in">hash_func</span>()  &#123;</span><br><span class="line">    m = <span class="number">1</span> &lt;&lt; b; </span><br><span class="line">    registers = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">int</span>[m]();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">stream_type</span>&gt;</span><br><span class="line">HyperLogLog&lt;stream_type&gt;::~<span class="built_in">HyperLogLog</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] registers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">stream_type</span>&gt;</span><br><span class="line"><span class="type">void</span> HyperLogLog&lt;stream_type&gt;::<span class="built_in">add</span>(stream_type v) &#123;</span><br><span class="line">    <span class="type">size_t</span> hv = <span class="built_in">hash_func</span>(v);</span><br><span class="line">    <span class="type">size_t</span> j = hv &gt;&gt; (<span class="built_in">sizeof</span>(<span class="type">size_t</span>) * <span class="number">8</span> - b);</span><br><span class="line">    <span class="type">size_t</span> w = hv &amp; ((<span class="number">1</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">size_t</span>) * <span class="number">8</span> - b) - <span class="number">1</span>);</span><br><span class="line">    registers[j] = std::<span class="built_in">max</span>(registers[j], <span class="built_in">msb_index</span>(w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">stream_type</span>&gt;</span><br><span class="line"><span class="type">double</span> HyperLogLog&lt;stream_type&gt;::<span class="built_in">estimate</span>() &#123;</span><br><span class="line">    <span class="comment">// return the harmonic mean (reciprocals of the mean of the reciprocals) of 2^&#123;register[i]&#125;</span></span><br><span class="line">    <span class="type">double</span> harmonic_mean = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        harmonic_mean += <span class="built_in">pow</span>(<span class="number">2.0</span>, -registers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    harmonic_mean = <span class="built_in">pow</span>(harmonic_mean, <span class="number">-1.0</span>) * m;</span><br><span class="line">    <span class="comment">// harmonic mean computed</span></span><br><span class="line">    <span class="keyword">return</span> harmonic_mean * m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The intuition behind this algorithm, as written by Flajolet et. al is: </p>
<blockquote>
<p>Let <code>$n$</code> be the unknown cardinality of stream <code>$S$</code>. Each substream will comprise approximately <code>$n/m$</code> elements. Then, its max-parameter should be close to <code>$\log_2(n/m)$</code>. The harmonic mean <code>$k$</code>  of the quantities <code>$2^&#123;Max&#125;$</code> is then likely to be of the order of <code>$n/m$</code>. Thus, <code>$mk$</code> should be of the order of <code>$n$</code>. </p>
</blockquote>
<p>In the above code for <strong>HyperLogLog::estimate</strong> the final result is a biased estimator, hence the authors multiply the estimate with a constant to remove the bias. The reasoning behind the value chosen is justified by complex math, hence why I have decided not to include the constant in this code.</p>
<h2 id="Why-does-HyperLogLog-work"><a href="#Why-does-HyperLogLog-work" class="headerlink" title="Why does HyperLogLog work?"></a>Why does HyperLogLog work?</h2><p>A thorough analysis of HyperLogLog is a complicated issue, requiring good knowledge of Complex analysis and statistical techniques such as Depossionisation. Mathematically adept readers <a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf" target="_blank" rel="noopener">can read the paper by Flajolet et. al</a>. I may revisit the topic when I have gained mathematical maturity.</p>
<h2 id="Where-is-HyperLogLog-used"><a href="#Where-is-HyperLogLog-used" class="headerlink" title="Where is HyperLogLog used?"></a>Where is HyperLogLog used?</h2><ul>
<li>In databases such as Redis, Presto and other SQL query engines.</li>
<li>Used by Reddit to provide a real-time estimate of reddit post counts [<a href="https://redditblog.com/2017/05/24/view-counting-at-reddit/" target="_blank" rel="noopener">Link</a>].</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://code.fb.com/data-infrastructure/hyperloglog/" target="_blank" rel="noopener">https://code.fb.com/data-infrastructure/hyperloglog/</a></p>
<p><a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/40671.pdf" target="_blank" rel="noopener">https://storage.googleapis.com/pub-tools-public-publication-data/pdf/40671.pdf</a></p>
<p><a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf" target="_blank" rel="noopener">http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf</a></p>
<p><a href="https://redditblog.com/2017/05/24/view-counting-at-reddit/" target="_blank" rel="noopener">https://redditblog.com/2017/05/24/view-counting-at-reddit/</a></p>

  </div>
  <div class="post-footer">
    
      <ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/HyperLogLog/" rel="tag">HyperLogLog</a></li></ul>
    

    <a href="#top" class="top">Back to Top</a>
  </div>
</article>
<footer>
  &copy; 2025
  <span class="author">
    Sooham Rafiz
  </span>
</footer>
    </div>
  </body>
</html>